   1               		.file	"uart.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	__vector_20
  13               	__vector_20:
  14               	.LFB1:
  15               		.file 1 "src/uart.c"
   1:src/uart.c    **** /*************************************************************************
   2:src/uart.c    **** Title:    Interrupt UART library with receive/transmit circular buffers
   3:src/uart.c    **** Author:   Peter Fleury <pfleury@gmx.ch>   http://tinyurl.com/peterfleury
   4:src/uart.c    **** File:     $Id: uart.c,v 1.15.2.4 2015/09/05 18:33:32 peter Exp $
   5:src/uart.c    **** Software: AVR-GCC 4.x
   6:src/uart.c    **** Hardware: any AVR with built-in UART, 
   7:src/uart.c    **** License:  GNU General Public License 
   8:src/uart.c    ****           
   9:src/uart.c    **** DESCRIPTION:
  10:src/uart.c    ****     An interrupt is generated when the UART has finished transmitting or
  11:src/uart.c    ****     receiving a byte. The interrupt handling routines use circular buffers
  12:src/uart.c    ****     for buffering received and transmitted data.
  13:src/uart.c    ****     
  14:src/uart.c    ****     The UART_RX_BUFFER_SIZE and UART_TX_BUFFER_SIZE variables define
  15:src/uart.c    ****     the buffer size in bytes. Note that these variables must be a 
  16:src/uart.c    ****     power of 2.
  17:src/uart.c    ****     
  18:src/uart.c    **** USAGE:
  19:src/uart.c    ****     Refere to the header file uart.h for a description of the routines. 
  20:src/uart.c    ****     See also example test_uart.c.
  21:src/uart.c    **** 
  22:src/uart.c    **** NOTES:
  23:src/uart.c    ****     Based on Atmel Application Note AVR306
  24:src/uart.c    ****                     
  25:src/uart.c    **** LICENSE:
  26:src/uart.c    ****     Copyright (C) 2015 Peter Fleury, GNU General Public License Version 3
  27:src/uart.c    **** 
  28:src/uart.c    ****     This program is free software; you can redistribute it and/or modify
  29:src/uart.c    ****     it under the terms of the GNU General Public License as published by
  30:src/uart.c    ****     the Free Software Foundation; either version 2 of the License, or
  31:src/uart.c    ****     any later version.
  32:src/uart.c    **** 
  33:src/uart.c    ****     This program is distributed in the hope that it will be useful,
  34:src/uart.c    ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  35:src/uart.c    ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  36:src/uart.c    ****     GNU General Public License for more details.
  37:src/uart.c    ****                         
  38:src/uart.c    **** *************************************************************************/
  39:src/uart.c    **** #include <avr/io.h>
  40:src/uart.c    **** #include <avr/interrupt.h>
  41:src/uart.c    **** #include <avr/pgmspace.h>
  42:src/uart.c    **** #include "uart.h"
  43:src/uart.c    **** 
  44:src/uart.c    **** 
  45:src/uart.c    **** /*
  46:src/uart.c    ****  *  constants and macros
  47:src/uart.c    ****  */
  48:src/uart.c    **** 
  49:src/uart.c    **** /* size of RX/TX buffers */
  50:src/uart.c    **** #define UART_RX_BUFFER_MASK ( UART_RX_BUFFER_SIZE - 1)
  51:src/uart.c    **** #define UART_TX_BUFFER_MASK ( UART_TX_BUFFER_SIZE - 1)
  52:src/uart.c    **** 
  53:src/uart.c    **** #if ( UART_RX_BUFFER_SIZE & UART_RX_BUFFER_MASK )
  54:src/uart.c    **** #error RX buffer size is not a power of 2
  55:src/uart.c    **** #endif
  56:src/uart.c    **** #if ( UART_TX_BUFFER_SIZE & UART_TX_BUFFER_MASK )
  57:src/uart.c    **** #error TX buffer size is not a power of 2
  58:src/uart.c    **** #endif
  59:src/uart.c    **** 
  60:src/uart.c    **** 
  61:src/uart.c    **** #if defined(__AVR_AT90S2313__) || defined(__AVR_AT90S4414__) || defined(__AVR_AT90S8515__) || \
  62:src/uart.c    ****     defined(__AVR_AT90S4434__) || defined(__AVR_AT90S8535__) || \
  63:src/uart.c    ****     defined(__AVR_ATmega103__)
  64:src/uart.c    ****  /* old AVR classic or ATmega103 with one UART */
  65:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect 
  66:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
  67:src/uart.c    ****  #define UART0_STATUS      USR
  68:src/uart.c    ****  #define UART0_CONTROL     UCR
  69:src/uart.c    ****  #define UART0_DATA        UDR  
  70:src/uart.c    ****  #define UART0_UDRIE       UDRIE
  71:src/uart.c    ****  #define UART0_UBRRL       UBRR
  72:src/uart.c    ****  #define UART0_BIT_U2X     U2X
  73:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
  74:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
  75:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
  76:src/uart.c    **** #elif defined(__AVR_AT90S2333__) || defined(__AVR_AT90S4433__)
  77:src/uart.c    ****  /* old AVR classic with one UART */
  78:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect 
  79:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
  80:src/uart.c    ****  #define UART0_STATUS      UCSRA
  81:src/uart.c    ****  #define UART0_CONTROL     UCSRB
  82:src/uart.c    ****  #define UART0_DATA        UDR 
  83:src/uart.c    ****  #define UART0_UDRIE       UDRIE
  84:src/uart.c    ****  #define UART0_UBRRL       UBRR
  85:src/uart.c    ****  #define UART0_BIT_U2X     U2X
  86:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
  87:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
  88:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
  89:src/uart.c    **** #elif defined(__AVR_AT90PWM216__) || defined(__AVR_AT90PWM316__) 
  90:src/uart.c    ****  /* AT90PWN216/316 with one USART */
  91:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
  92:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
  93:src/uart.c    ****  #define UART0_STATUS      UCSRA
  94:src/uart.c    ****  #define UART0_CONTROL     UCSRB
  95:src/uart.c    ****  #define UART0_CONTROLC    UCSRC
  96:src/uart.c    ****  #define UART0_DATA        UDR
  97:src/uart.c    ****  #define UART0_UDRIE       UDRIE
  98:src/uart.c    ****  #define UART0_UBRRL       UBRRL
  99:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 100:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 101:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 102:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 103:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 104:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 105:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1 
 106:src/uart.c    **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega8A__) || \
 107:src/uart.c    ****       defined(__AVR_ATmega16__) || defined(__AVR_ATmega16A__) || \
 108:src/uart.c    ****       defined(__AVR_ATmega32__) || defined(__AVR_ATmega32A__) || \
 109:src/uart.c    ****       defined(__AVR_ATmega323__)
 110:src/uart.c    ****  /* ATmega with one USART */
 111:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RXC_vect
 112:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 113:src/uart.c    ****  #define UART0_STATUS      UCSRA
 114:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 115:src/uart.c    ****  #define UART0_CONTROLC    UCSRC
 116:src/uart.c    ****  #define UART0_DATA        UDR
 117:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 118:src/uart.c    ****  #define UART0_UBRRL       UBRRL
 119:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 120:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 121:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 122:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 123:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 124:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 125:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1
 126:src/uart.c    ****  #define UART0_BIT_URSEL   URSEL
 127:src/uart.c    **** #elif defined (__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 128:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 129:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 130:src/uart.c    ****  #define UART0_STATUS      UCSRA
 131:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 132:src/uart.c    ****  #define UART0_CONTROLC    UCSRC 
 133:src/uart.c    ****  #define UART0_DATA        UDR
 134:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 135:src/uart.c    ****  #define UART0_UBRRL       UBRRL
 136:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 137:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 138:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 139:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 140:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 141:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 142:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1
 143:src/uart.c    ****  #define UART0_BIT_URSEL   URSEL
 144:src/uart.c    **** #elif defined(__AVR_ATmega163__)
 145:src/uart.c    ****   /* ATmega163 with one UART */
 146:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect
 147:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
 148:src/uart.c    ****  #define UART0_STATUS      UCSRA
 149:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 150:src/uart.c    ****  #define UART0_DATA        UDR
 151:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 152:src/uart.c    ****  #define UART0_UBRRL       UBRR
 153:src/uart.c    ****  #define UART0_UBRRH       UBRRHI
 154:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 155:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 156:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 157:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 158:src/uart.c    **** #elif defined(__AVR_ATmega162__) 
 159:src/uart.c    ****  /* ATmega with two USART */
 160:src/uart.c    ****  #define ATMEGA_USART1
 161:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART0_RXC_vect
 162:src/uart.c    ****  #define UART1_RECEIVE_INTERRUPT   USART1_RXC_vect
 163:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 164:src/uart.c    ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 165:src/uart.c    ****  #define UART0_STATUS      UCSR0A
 166:src/uart.c    ****  #define UART0_CONTROL     UCSR0B
 167:src/uart.c    ****  #define UART0_CONTROLC    UCSR0C
 168:src/uart.c    ****  #define UART0_DATA        UDR0
 169:src/uart.c    ****  #define UART0_UDRIE       UDRIE0
 170:src/uart.c    ****  #define UART0_UBRRL       UBRR0L
 171:src/uart.c    ****  #define UART0_UBRRH       UBRR0H
 172:src/uart.c    ****  #define UART0_BIT_URSEL   URSEL0
 173:src/uart.c    ****  #define UART0_BIT_U2X     U2X0
 174:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE0
 175:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN0
 176:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN0
 177:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ00
 178:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ01
 179:src/uart.c    ****  #define UART1_STATUS      UCSR1A
 180:src/uart.c    ****  #define UART1_CONTROL     UCSR1B
 181:src/uart.c    ****  #define UART1_CONTROLC    UCSR1C
 182:src/uart.c    ****  #define UART1_DATA        UDR1
 183:src/uart.c    ****  #define UART1_UDRIE       UDRIE1
 184:src/uart.c    ****  #define UART1_UBRRL       UBRR1L
 185:src/uart.c    ****  #define UART1_UBRRH       UBRR1H
 186:src/uart.c    ****  #define UART1_BIT_URSEL   URSEL1
 187:src/uart.c    ****  #define UART1_BIT_U2X     U2X1
 188:src/uart.c    ****  #define UART1_BIT_RXCIE   RXCIE1
 189:src/uart.c    ****  #define UART1_BIT_RXEN    RXEN1
 190:src/uart.c    ****  #define UART1_BIT_TXEN    TXEN1
 191:src/uart.c    ****  #define UART1_BIT_UCSZ0   UCSZ10
 192:src/uart.c    ****  #define UART1_BIT_UCSZ1   UCSZ11 
 193:src/uart.c    **** #elif defined(__AVR_ATmega161__)
 194:src/uart.c    ****  /* ATmega with UART */
 195:src/uart.c    ****  #error "AVR ATmega161 currently not supported by this libaray !"
 196:src/uart.c    **** #elif defined(__AVR_ATmega169__)
 197:src/uart.c    ****  /* ATmega with one USART */
 198:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 199:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 200:src/uart.c    ****  #define UART0_STATUS      UCSRA
 201:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 202:src/uart.c    ****  #define UART0_CONTROLC    UCSRC
 203:src/uart.c    ****  #define UART0_DATA        UDR
 204:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 205:src/uart.c    ****  #define UART0_UBRRL       UBRRL
 206:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 207:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 208:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 209:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 210:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 211:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 212:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1
 213:src/uart.c    **** #elif defined(__AVR_ATmega48__) || defined(__AVR_ATmega48A__) || defined(__AVR_ATmega48P__) || defi
 214:src/uart.c    ****       defined(__AVR_ATmega88__) || defined(__AVR_ATmega88A__) || defined(__AVR_ATmega88P__) || defi
 215:src/uart.c    ****       defined(__AVR_ATmega168__) || defined(__AVR_ATmega168A__)|| defined(__AVR_ATmega168P__)|| def
 216:src/uart.c    ****       defined(__AVR_ATmega328__) || defined(__AVR_ATmega328P__) || \
 217:src/uart.c    ****       defined(__AVR_ATmega3250__) || defined(__AVR_ATmega3290__) ||defined(__AVR_ATmega6450__) || d
 218:src/uart.c    ****  /* ATmega with one USART */
 219:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 220:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 221:src/uart.c    ****  #define UART0_STATUS      UCSR0A
 222:src/uart.c    ****  #define UART0_CONTROL     UCSR0B
 223:src/uart.c    ****  #define UART0_CONTROLC    UCSR0C
 224:src/uart.c    ****  #define UART0_DATA        UDR0
 225:src/uart.c    ****  #define UART0_UDRIE       UDRIE0
 226:src/uart.c    ****  #define UART0_UBRRL       UBRR0L
 227:src/uart.c    ****  #define UART0_UBRRH       UBRR0H
 228:src/uart.c    ****  #define UART0_BIT_U2X     U2X0
 229:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE0
 230:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN0
 231:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN0
 232:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ00
 233:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ01
 234:src/uart.c    **** #elif defined(__AVR_ATtiny2313__) || defined(__AVR_ATtiny2313A__) || defined(__AVR_ATtiny4313__)
 235:src/uart.c    ****  /* ATtiny with one USART */
 236:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 237:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 238:src/uart.c    ****  #define UART0_STATUS      UCSRA
 239:src/uart.c    ****  #define UART0_CONTROL     UCSRB
 240:src/uart.c    ****  #define UART0_CONTROLC    UCSRC
 241:src/uart.c    ****  #define UART0_DATA        UDR
 242:src/uart.c    ****  #define UART0_UDRIE       UDRIE
 243:src/uart.c    ****  #define UART0_UBRRL       UBRRL
 244:src/uart.c    ****  #define UART0_UBRRH       UBRRH
 245:src/uart.c    ****  #define UART0_BIT_U2X     U2X
 246:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE
 247:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN
 248:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN
 249:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ0
 250:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ1
 251:src/uart.c    **** #elif defined(__AVR_ATmega329__) || defined(__AVR_ATmega649__) || defined(__AVR_ATmega3290__) || de
 252:src/uart.c    ****       defined(__AVR_ATmega169A__) || defined(__AVR_ATmega169PA__) || \
 253:src/uart.c    ****       defined(__AVR_ATmega329A__) || defined(__AVR_ATmega329PA__) || defined(__AVR_ATmega3290A__) |
 254:src/uart.c    ****       defined(__AVR_ATmega649A__) || defined(__AVR_ATmega649P__) || defined(__AVR_ATmega6490A__) ||
 255:src/uart.c    ****       defined(__AVR_ATmega165__) || defined(__AVR_ATmega325__) || defined(__AVR_ATmega645__) || def
 256:src/uart.c    ****       defined(__AVR_ATmega165A__) || defined(__AVR_ATmega165PA__) || \
 257:src/uart.c    ****       defined(__AVR_ATmega325A__) || defined(__AVR_ATmega325PA__) || defined(__AVR_ATmega3250A__) |
 258:src/uart.c    ****       defined(__AVR_ATmega645A__) || defined(__AVR_ATmega645PA__) || defined(__AVR_ATmega6450A__) |
 259:src/uart.c    ****       defined(__AVR_ATmega644__)
 260:src/uart.c    ****  /* ATmega with one USART */
 261:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 262:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 263:src/uart.c    ****  #define UART0_STATUS      UCSR0A
 264:src/uart.c    ****  #define UART0_CONTROL     UCSR0B
 265:src/uart.c    ****  #define UART0_CONTROLC    UCSR0C
 266:src/uart.c    ****  #define UART0_DATA        UDR0
 267:src/uart.c    ****  #define UART0_UDRIE       UDRIE0
 268:src/uart.c    ****  #define UART0_UBRRL       UBRR0L
 269:src/uart.c    ****  #define UART0_UBRRH       UBRR0H
 270:src/uart.c    ****  #define UART0_BIT_U2X     U2X0
 271:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE0
 272:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN0
 273:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN0
 274:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ00
 275:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ01
 276:src/uart.c    **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega128A__) ||\
 277:src/uart.c    ****       defined(__AVR_ATmega640__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__) || d
 278:src/uart.c    ****       defined(__AVR_ATmega164P__) || defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__) || 
 279:src/uart.c    ****       defined(__AVR_ATmega164A__) || defined(__AVR_ATmega164PA__) || defined(__AVR_ATmega324A__) ||
 280:src/uart.c    ****       defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284__) ||
 281:src/uart.c    ****       defined(__AVR_ATtiny1634__)
 282:src/uart.c    ****  /* ATmega with two USART */
 283:src/uart.c    ****  #define ATMEGA_USART1
 284:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 285:src/uart.c    ****  #define UART1_RECEIVE_INTERRUPT   USART1_RX_vect
 286:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 287:src/uart.c    ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 288:src/uart.c    ****  #define UART0_STATUS      UCSR0A
 289:src/uart.c    ****  #define UART0_CONTROL     UCSR0B
 290:src/uart.c    ****  #define UART0_CONTROLC    UCSR0C  
 291:src/uart.c    ****  #define UART0_DATA        UDR0
 292:src/uart.c    ****  #define UART0_UDRIE       UDRIE0
 293:src/uart.c    ****  #define UART0_UBRRL       UBRR0L
 294:src/uart.c    ****  #define UART0_UBRRH       UBRR0H
 295:src/uart.c    ****  #define UART0_BIT_U2X     U2X0
 296:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE0
 297:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN0
 298:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN0
 299:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ00
 300:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ01 
 301:src/uart.c    ****  #define UART1_STATUS      UCSR1A
 302:src/uart.c    ****  #define UART1_CONTROL     UCSR1B
 303:src/uart.c    ****  #define UART1_CONTROLC    UCSR1C  
 304:src/uart.c    ****  #define UART1_DATA        UDR1
 305:src/uart.c    ****  #define UART1_UDRIE       UDRIE1
 306:src/uart.c    ****  #define UART1_UBRRL       UBRR1L
 307:src/uart.c    ****  #define UART1_UBRRH       UBRR1H
 308:src/uart.c    ****  #define UART1_BIT_U2X     U2X1
 309:src/uart.c    ****  #define UART1_BIT_RXCIE   RXCIE1
 310:src/uart.c    ****  #define UART1_BIT_RXEN    RXEN1
 311:src/uart.c    ****  #define UART1_BIT_TXEN    TXEN1
 312:src/uart.c    ****  #define UART1_BIT_UCSZ0   UCSZ10
 313:src/uart.c    ****  #define UART1_BIT_UCSZ1   UCSZ11
 314:src/uart.c    **** #elif defined(__AVR_ATmega8U2__) || defined(__AVR_ATmega16U2__) || defined(__AVR_ATmega32U2__) || \
 315:src/uart.c    ****       defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__) || \
 316:src/uart.c    ****       defined(__AVR_AT90USB82__) || defined(__AVR_AT90USB162__) || \
 317:src/uart.c    ****       defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB647__) ||
 318:src/uart.c    ****  #define UART0_RECEIVE_INTERRUPT   USART1_RX_vect
 319:src/uart.c    ****  #define UART0_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 320:src/uart.c    ****  #define UART0_STATUS      UCSR1A
 321:src/uart.c    ****  #define UART0_CONTROL     UCSR1B
 322:src/uart.c    ****  #define UART0_CONTROLC    UCSR1C
 323:src/uart.c    ****  #define UART0_DATA        UDR1
 324:src/uart.c    ****  #define UART0_UDRIE       UDRIE1
 325:src/uart.c    ****  #define UART0_UBRRL       UBRR1L
 326:src/uart.c    ****  #define UART0_UBRRH       UBRR1H
 327:src/uart.c    ****  #define UART0_BIT_U2X     U2X1
 328:src/uart.c    ****  #define UART0_BIT_RXCIE   RXCIE1
 329:src/uart.c    ****  #define UART0_BIT_RXEN    RXEN1
 330:src/uart.c    ****  #define UART0_BIT_TXEN    TXEN1
 331:src/uart.c    ****  #define UART0_BIT_UCSZ0   UCSZ10
 332:src/uart.c    ****  #define UART0_BIT_UCSZ1   UCSZ11
 333:src/uart.c    **** #else
 334:src/uart.c    ****  #error "no UART definition for MCU available"
 335:src/uart.c    **** #endif
 336:src/uart.c    **** 
 337:src/uart.c    **** 
 338:src/uart.c    **** 
 339:src/uart.c    **** /*
 340:src/uart.c    ****  *  module global variables
 341:src/uart.c    ****  */
 342:src/uart.c    **** static volatile unsigned char UART_TxBuf[UART_TX_BUFFER_SIZE];
 343:src/uart.c    **** static volatile unsigned char UART_RxBuf[UART_RX_BUFFER_SIZE];
 344:src/uart.c    **** static volatile unsigned char UART_TxHead;
 345:src/uart.c    **** static volatile unsigned char UART_TxTail;
 346:src/uart.c    **** static volatile unsigned char UART_RxHead;
 347:src/uart.c    **** static volatile unsigned char UART_RxTail;
 348:src/uart.c    **** static volatile unsigned char UART_LastRxError;
 349:src/uart.c    **** 
 350:src/uart.c    **** #if defined( ATMEGA_USART1 )
 351:src/uart.c    **** static volatile unsigned char UART1_TxBuf[UART_TX_BUFFER_SIZE];
 352:src/uart.c    **** static volatile unsigned char UART1_RxBuf[UART_RX_BUFFER_SIZE];
 353:src/uart.c    **** static volatile unsigned char UART1_TxHead;
 354:src/uart.c    **** static volatile unsigned char UART1_TxTail;
 355:src/uart.c    **** static volatile unsigned char UART1_RxHead;
 356:src/uart.c    **** static volatile unsigned char UART1_RxTail;
 357:src/uart.c    **** static volatile unsigned char UART1_LastRxError;
 358:src/uart.c    **** #endif
 359:src/uart.c    **** 
 360:src/uart.c    **** 
 361:src/uart.c    **** 
 362:src/uart.c    **** ISR (UART0_RECEIVE_INTERRUPT)	
 363:src/uart.c    **** /*************************************************************************
 364:src/uart.c    **** Function: UART Receive Complete interrupt
 365:src/uart.c    **** Purpose:  called when the UART has received a character
 366:src/uart.c    **** **************************************************************************/
 367:src/uart.c    **** {
  16               		.loc 1 367 0
  17               		.cfi_startproc
  18 0000 1F92      		push r1
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 1, -2
  22 0002 0F92      		push r0
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 0, -3
  26 0004 0FB6      		in r0,__SREG__
  27 0006 0F92      		push r0
  28 0008 1124      		clr __zero_reg__
  29 000a 0BB6      		in r0,__RAMPZ__
  30 000c 0F92      		push r0
  31 000e 2F93      		push r18
  32               	.LCFI2:
  33               		.cfi_def_cfa_offset 5
  34               		.cfi_offset 18, -4
  35 0010 8F93      		push r24
  36               	.LCFI3:
  37               		.cfi_def_cfa_offset 6
  38               		.cfi_offset 24, -5
  39 0012 9F93      		push r25
  40               	.LCFI4:
  41               		.cfi_def_cfa_offset 7
  42               		.cfi_offset 25, -6
  43 0014 EF93      		push r30
  44               	.LCFI5:
  45               		.cfi_def_cfa_offset 8
  46               		.cfi_offset 30, -7
  47 0016 FF93      		push r31
  48               	.LCFI6:
  49               		.cfi_def_cfa_offset 9
  50               		.cfi_offset 31, -8
  51               	/* prologue: Signal */
  52               	/* frame size = 0 */
  53               	/* stack size = 9 */
  54               	.L__stack_usage = 9
 368:src/uart.c    ****     unsigned char tmphead;
 369:src/uart.c    ****     unsigned char data;
 370:src/uart.c    ****     unsigned char usr;
 371:src/uart.c    ****     unsigned char lastRxError;
 372:src/uart.c    ****  
 373:src/uart.c    ****  
 374:src/uart.c    ****     /* read UART status register and UART data register */
 375:src/uart.c    ****     usr  = UART0_STATUS;
  55               		.loc 1 375 0
  56 0018 8091 C000 		lds r24,192
  57               	.LVL0:
 376:src/uart.c    ****     data = UART0_DATA;
  58               		.loc 1 376 0
  59 001c 9091 C600 		lds r25,198
  60               	.LVL1:
 377:src/uart.c    ****     
 378:src/uart.c    ****     /* get FEn (Frame Error) DORn (Data OverRun) UPEn (USART Parity Error) bits */
 379:src/uart.c    **** #if defined(FE) && defined(DOR) && defined(UPE)
 380:src/uart.c    ****     lastRxError = usr & (_BV(FE)|_BV(DOR)|_BV(UPE) );
 381:src/uart.c    **** #elif defined(FE0) && defined(DOR0) && defined(UPE0)
 382:src/uart.c    ****     lastRxError = usr & (_BV(FE0)|_BV(DOR0)|_BV(UPE0) );
  61               		.loc 1 382 0
  62 0020 8C71      		andi r24,lo8(28)
  63               	.LVL2:
 383:src/uart.c    **** #elif defined(FE1) && defined(DOR1) && defined(UPE1)
 384:src/uart.c    ****     lastRxError = usr & (_BV(FE1)|_BV(DOR1)|_BV(UPE1) );
 385:src/uart.c    **** #elif defined(FE) && defined(DOR)
 386:src/uart.c    ****     lastRxError = usr & (_BV(FE)|_BV(DOR) );
 387:src/uart.c    **** #endif
 388:src/uart.c    **** 
 389:src/uart.c    ****     /* calculate buffer index */ 
 390:src/uart.c    ****     tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
  64               		.loc 1 390 0
  65 0022 E091 0000 		lds r30,UART_RxHead
  66 0026 EF5F      		subi r30,lo8(-(1))
  67 0028 EF77      		andi r30,lo8(127)
  68               	.LVL3:
 391:src/uart.c    ****     
 392:src/uart.c    ****     if ( tmphead == UART_RxTail ) {
  69               		.loc 1 392 0
  70 002a 2091 0000 		lds r18,UART_RxTail
  71 002e E217      		cp r30,r18
  72 0030 01F0      		breq .L3
 393:src/uart.c    ****         /* error: receive buffer overflow */
 394:src/uart.c    ****         lastRxError = UART_BUFFER_OVERFLOW >> 8;
 395:src/uart.c    ****     }else{
 396:src/uart.c    ****         /* store new index */
 397:src/uart.c    ****         UART_RxHead = tmphead;
  73               		.loc 1 397 0
  74 0032 E093 0000 		sts UART_RxHead,r30
 398:src/uart.c    ****         /* store received data in buffer */
 399:src/uart.c    ****         UART_RxBuf[tmphead] = data;
  75               		.loc 1 399 0
  76 0036 F0E0      		ldi r31,0
  77 0038 E050      		subi r30,lo8(-(UART_RxBuf))
  78 003a F040      		sbci r31,hi8(-(UART_RxBuf))
  79               	.LVL4:
  80 003c 9083      		st Z,r25
  81               	.LVL5:
  82 003e 00C0      		rjmp .L2
  83               	.LVL6:
  84               	.L3:
 394:src/uart.c    ****     }else{
  85               		.loc 1 394 0
  86 0040 82E0      		ldi r24,lo8(2)
  87               	.LVL7:
  88               	.L2:
 400:src/uart.c    ****     }
 401:src/uart.c    ****     UART_LastRxError |= lastRxError;   
  89               		.loc 1 401 0
  90 0042 9091 0000 		lds r25,UART_LastRxError
  91               	.LVL8:
  92 0046 892B      		or r24,r25
  93               	.LVL9:
  94 0048 8093 0000 		sts UART_LastRxError,r24
  95               	/* epilogue start */
 402:src/uart.c    **** }
  96               		.loc 1 402 0
  97 004c FF91      		pop r31
  98 004e EF91      		pop r30
  99 0050 9F91      		pop r25
 100 0052 8F91      		pop r24
 101 0054 2F91      		pop r18
 102 0056 0F90      		pop r0
 103 0058 0BBE      		out __RAMPZ__,r0
 104 005a 0F90      		pop r0
 105 005c 0FBE      		out __SREG__,r0
 106 005e 0F90      		pop r0
 107 0060 1F90      		pop r1
 108 0062 1895      		reti
 109               		.cfi_endproc
 110               	.LFE1:
 112               	.global	__vector_21
 114               	__vector_21:
 115               	.LFB2:
 403:src/uart.c    **** 
 404:src/uart.c    **** 
 405:src/uart.c    **** ISR (UART0_TRANSMIT_INTERRUPT)
 406:src/uart.c    **** /*************************************************************************
 407:src/uart.c    **** Function: UART Data Register Empty interrupt
 408:src/uart.c    **** Purpose:  called when the UART is ready to transmit the next byte
 409:src/uart.c    **** **************************************************************************/
 410:src/uart.c    **** {
 116               		.loc 1 410 0
 117               		.cfi_startproc
 118 0064 1F92      		push r1
 119               	.LCFI7:
 120               		.cfi_def_cfa_offset 3
 121               		.cfi_offset 1, -2
 122 0066 0F92      		push r0
 123               	.LCFI8:
 124               		.cfi_def_cfa_offset 4
 125               		.cfi_offset 0, -3
 126 0068 0FB6      		in r0,__SREG__
 127 006a 0F92      		push r0
 128 006c 1124      		clr __zero_reg__
 129 006e 0BB6      		in r0,__RAMPZ__
 130 0070 0F92      		push r0
 131 0072 8F93      		push r24
 132               	.LCFI9:
 133               		.cfi_def_cfa_offset 5
 134               		.cfi_offset 24, -4
 135 0074 9F93      		push r25
 136               	.LCFI10:
 137               		.cfi_def_cfa_offset 6
 138               		.cfi_offset 25, -5
 139 0076 EF93      		push r30
 140               	.LCFI11:
 141               		.cfi_def_cfa_offset 7
 142               		.cfi_offset 30, -6
 143 0078 FF93      		push r31
 144               	.LCFI12:
 145               		.cfi_def_cfa_offset 8
 146               		.cfi_offset 31, -7
 147               	/* prologue: Signal */
 148               	/* frame size = 0 */
 149               	/* stack size = 8 */
 150               	.L__stack_usage = 8
 411:src/uart.c    ****     unsigned char tmptail;
 412:src/uart.c    **** 
 413:src/uart.c    ****     
 414:src/uart.c    ****     if ( UART_TxHead != UART_TxTail) {
 151               		.loc 1 414 0
 152 007a 9091 0000 		lds r25,UART_TxHead
 153 007e 8091 0000 		lds r24,UART_TxTail
 154 0082 9817      		cp r25,r24
 155 0084 01F0      		breq .L6
 415:src/uart.c    ****         /* calculate and store new buffer index */
 416:src/uart.c    ****         tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 156               		.loc 1 416 0
 157 0086 E091 0000 		lds r30,UART_TxTail
 158 008a EF5F      		subi r30,lo8(-(1))
 159 008c EF77      		andi r30,lo8(127)
 160               	.LVL10:
 417:src/uart.c    ****         UART_TxTail = tmptail;
 161               		.loc 1 417 0
 162 008e E093 0000 		sts UART_TxTail,r30
 418:src/uart.c    ****         /* get one byte from buffer and write it to UART */
 419:src/uart.c    ****         UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 163               		.loc 1 419 0
 164 0092 F0E0      		ldi r31,0
 165 0094 E050      		subi r30,lo8(-(UART_TxBuf))
 166 0096 F040      		sbci r31,hi8(-(UART_TxBuf))
 167               	.LVL11:
 168 0098 8081      		ld r24,Z
 169 009a 8093 C600 		sts 198,r24
 170               	.LVL12:
 171 009e 00C0      		rjmp .L5
 172               	.L6:
 420:src/uart.c    ****     }else{
 421:src/uart.c    ****         /* tx buffer empty, disable UDRE interrupt */
 422:src/uart.c    ****         UART0_CONTROL &= ~_BV(UART0_UDRIE);
 173               		.loc 1 422 0
 174 00a0 8091 C100 		lds r24,193
 175 00a4 8F7D      		andi r24,lo8(-33)
 176 00a6 8093 C100 		sts 193,r24
 177               	.L5:
 178               	/* epilogue start */
 423:src/uart.c    ****     }
 424:src/uart.c    **** }
 179               		.loc 1 424 0
 180 00aa FF91      		pop r31
 181 00ac EF91      		pop r30
 182 00ae 9F91      		pop r25
 183 00b0 8F91      		pop r24
 184 00b2 0F90      		pop r0
 185 00b4 0BBE      		out __RAMPZ__,r0
 186 00b6 0F90      		pop r0
 187 00b8 0FBE      		out __SREG__,r0
 188 00ba 0F90      		pop r0
 189 00bc 1F90      		pop r1
 190 00be 1895      		reti
 191               		.cfi_endproc
 192               	.LFE2:
 194               	.global	uart_init
 196               	uart_init:
 197               	.LFB3:
 425:src/uart.c    **** 
 426:src/uart.c    **** 
 427:src/uart.c    **** /*************************************************************************
 428:src/uart.c    **** Function: uart_init()
 429:src/uart.c    **** Purpose:  initialize UART and set baudrate
 430:src/uart.c    **** Input:    baudrate using macro UART_BAUD_SELECT()
 431:src/uart.c    **** Returns:  none
 432:src/uart.c    **** **************************************************************************/
 433:src/uart.c    **** void uart_init(unsigned int baudrate)
 434:src/uart.c    **** {
 198               		.loc 1 434 0
 199               		.cfi_startproc
 200               	.LVL13:
 201               	/* prologue: function */
 202               	/* frame size = 0 */
 203               	/* stack size = 0 */
 204               	.L__stack_usage = 0
 435:src/uart.c    ****     UART_TxHead = 0;
 205               		.loc 1 435 0
 206 00c0 1092 0000 		sts UART_TxHead,__zero_reg__
 436:src/uart.c    ****     UART_TxTail = 0;
 207               		.loc 1 436 0
 208 00c4 1092 0000 		sts UART_TxTail,__zero_reg__
 437:src/uart.c    ****     UART_RxHead = 0;
 209               		.loc 1 437 0
 210 00c8 1092 0000 		sts UART_RxHead,__zero_reg__
 438:src/uart.c    ****     UART_RxTail = 0;
 211               		.loc 1 438 0
 212 00cc 1092 0000 		sts UART_RxTail,__zero_reg__
 439:src/uart.c    **** 
 440:src/uart.c    **** #ifdef UART_TEST
 441:src/uart.c    **** #ifndef UART0_BIT_U2X
 442:src/uart.c    **** #warning "UART0_BIT_U2X not defined"
 443:src/uart.c    **** #endif
 444:src/uart.c    **** #ifndef UART0_UBRRH
 445:src/uart.c    **** #warning "UART0_UBRRH not defined"
 446:src/uart.c    **** #endif
 447:src/uart.c    **** #ifndef UART0_CONTROLC
 448:src/uart.c    **** #warning "UART0_CONTROLC not defined"
 449:src/uart.c    **** #endif
 450:src/uart.c    **** #if defined(URSEL) || defined(URSEL0)
 451:src/uart.c    **** #ifndef UART0_BIT_URSEL
 452:src/uart.c    **** #warning "UART0_BIT_URSEL not defined"
 453:src/uart.c    **** #endif
 454:src/uart.c    **** #endif
 455:src/uart.c    **** #endif
 456:src/uart.c    **** 
 457:src/uart.c    ****     /* Set baud rate */
 458:src/uart.c    ****     if ( baudrate & 0x8000 )
 213               		.loc 1 458 0
 214 00d0 97FF      		sbrs r25,7
 215 00d2 00C0      		rjmp .L9
 459:src/uart.c    ****     {
 460:src/uart.c    ****         #if UART0_BIT_U2X
 461:src/uart.c    ****         UART0_STATUS = (1<<UART0_BIT_U2X);  //Enable 2x speed 
 216               		.loc 1 461 0
 217 00d4 22E0      		ldi r18,lo8(2)
 218 00d6 2093 C000 		sts 192,r18
 219               	.L9:
 462:src/uart.c    ****         #endif
 463:src/uart.c    ****     } 
 464:src/uart.c    ****     #if defined(UART0_UBRRH)
 465:src/uart.c    ****     UART0_UBRRH = (unsigned char)((baudrate>>8)&0x80) ;
 220               		.loc 1 465 0
 221 00da 9078      		andi r25,lo8(-128)
 222 00dc 9093 C500 		sts 197,r25
 466:src/uart.c    ****     #endif    
 467:src/uart.c    ****     UART0_UBRRL = (unsigned char) (baudrate&0x00FF);
 223               		.loc 1 467 0
 224 00e0 8093 C400 		sts 196,r24
 468:src/uart.c    ****       
 469:src/uart.c    ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 470:src/uart.c    ****     UART0_CONTROL = _BV(UART0_BIT_RXCIE)|(1<<UART0_BIT_RXEN)|(1<<UART0_BIT_TXEN);
 225               		.loc 1 470 0
 226 00e4 88E9      		ldi r24,lo8(-104)
 227               	.LVL14:
 228 00e6 8093 C100 		sts 193,r24
 471:src/uart.c    ****     
 472:src/uart.c    ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 473:src/uart.c    ****     #ifdef UART0_CONTROLC
 474:src/uart.c    ****     #ifdef UART0_BIT_URSEL
 475:src/uart.c    ****     UART0_CONTROLC = (1<<UART0_BIT_URSEL)|(1<<UART0_BIT_UCSZ1)|(1<<UART0_BIT_UCSZ0);
 476:src/uart.c    ****     #else
 477:src/uart.c    ****     UART0_CONTROLC = (1<<UART0_BIT_UCSZ1)|(1<<UART0_BIT_UCSZ0);
 229               		.loc 1 477 0
 230 00ea 86E0      		ldi r24,lo8(6)
 231 00ec 8093 C200 		sts 194,r24
 232 00f0 0895      		ret
 233               		.cfi_endproc
 234               	.LFE3:
 236               	.global	uart_getc
 238               	uart_getc:
 239               	.LFB4:
 478:src/uart.c    ****     #endif 
 479:src/uart.c    ****     #endif
 480:src/uart.c    **** 
 481:src/uart.c    **** }/* uart_init */
 482:src/uart.c    **** 
 483:src/uart.c    **** 
 484:src/uart.c    **** /*************************************************************************
 485:src/uart.c    **** Function: uart_getc()
 486:src/uart.c    **** Purpose:  return byte from ringbuffer  
 487:src/uart.c    **** Returns:  lower byte:  received byte from ringbuffer
 488:src/uart.c    ****           higher byte: last receive error
 489:src/uart.c    **** **************************************************************************/
 490:src/uart.c    **** unsigned int uart_getc(void)
 491:src/uart.c    **** {    
 240               		.loc 1 491 0
 241               		.cfi_startproc
 242               	/* prologue: function */
 243               	/* frame size = 0 */
 244               	/* stack size = 0 */
 245               	.L__stack_usage = 0
 492:src/uart.c    ****     unsigned char tmptail;
 493:src/uart.c    ****     unsigned char data;
 494:src/uart.c    ****     unsigned char lastRxError;
 495:src/uart.c    **** 
 496:src/uart.c    **** 
 497:src/uart.c    ****     if ( UART_RxHead == UART_RxTail ) {
 246               		.loc 1 497 0
 247 00f2 9091 0000 		lds r25,UART_RxHead
 248 00f6 8091 0000 		lds r24,UART_RxTail
 249 00fa 9817      		cp r25,r24
 250 00fc 01F0      		breq .L12
 498:src/uart.c    ****         return UART_NO_DATA;   /* no data available */
 499:src/uart.c    ****     }
 500:src/uart.c    ****     
 501:src/uart.c    ****     /* calculate buffer index */
 502:src/uart.c    ****     tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
 251               		.loc 1 502 0
 252 00fe 9091 0000 		lds r25,UART_RxTail
 253 0102 9F5F      		subi r25,lo8(-(1))
 254 0104 9F77      		andi r25,lo8(127)
 255               	.LVL15:
 503:src/uart.c    ****     
 504:src/uart.c    ****     /* get data from receive buffer */
 505:src/uart.c    ****     data = UART_RxBuf[tmptail];
 256               		.loc 1 505 0
 257 0106 E92F      		mov r30,r25
 258 0108 F0E0      		ldi r31,0
 259 010a E050      		subi r30,lo8(-(UART_RxBuf))
 260 010c F040      		sbci r31,hi8(-(UART_RxBuf))
 261 010e 2081      		ld r18,Z
 262               	.LVL16:
 506:src/uart.c    ****     lastRxError = UART_LastRxError;
 263               		.loc 1 506 0
 264 0110 8091 0000 		lds r24,UART_LastRxError
 265               	.LVL17:
 507:src/uart.c    ****     
 508:src/uart.c    ****     /* store buffer index */
 509:src/uart.c    ****     UART_RxTail = tmptail; 
 266               		.loc 1 509 0
 267 0114 9093 0000 		sts UART_RxTail,r25
 510:src/uart.c    ****     
 511:src/uart.c    ****     UART_LastRxError = 0;
 268               		.loc 1 511 0
 269 0118 1092 0000 		sts UART_LastRxError,__zero_reg__
 512:src/uart.c    ****     return (lastRxError << 8) + data;
 270               		.loc 1 512 0
 271 011c 90E0      		ldi r25,0
 272               	.LVL18:
 273 011e 982F      		mov r25,r24
 274 0120 8827      		clr r24
 275               	.LVL19:
 276 0122 820F      		add r24,r18
 277 0124 911D      		adc r25,__zero_reg__
 278 0126 0895      		ret
 279               	.LVL20:
 280               	.L12:
 498:src/uart.c    ****     }
 281               		.loc 1 498 0
 282 0128 80E0      		ldi r24,0
 283 012a 91E0      		ldi r25,lo8(1)
 513:src/uart.c    **** 
 514:src/uart.c    **** }/* uart_getc */
 284               		.loc 1 514 0
 285 012c 0895      		ret
 286               		.cfi_endproc
 287               	.LFE4:
 289               	.global	uart_putc
 291               	uart_putc:
 292               	.LFB5:
 515:src/uart.c    **** 
 516:src/uart.c    **** 
 517:src/uart.c    **** /*************************************************************************
 518:src/uart.c    **** Function: uart_putc()
 519:src/uart.c    **** Purpose:  write byte to ringbuffer for transmitting via UART
 520:src/uart.c    **** Input:    byte to be transmitted
 521:src/uart.c    **** Returns:  none          
 522:src/uart.c    **** **************************************************************************/
 523:src/uart.c    **** void uart_putc(unsigned char data)
 524:src/uart.c    **** {
 293               		.loc 1 524 0
 294               		.cfi_startproc
 295               	.LVL21:
 296               	/* prologue: function */
 297               	/* frame size = 0 */
 298               	/* stack size = 0 */
 299               	.L__stack_usage = 0
 525:src/uart.c    ****     unsigned char tmphead;
 526:src/uart.c    **** 
 527:src/uart.c    ****     
 528:src/uart.c    ****     tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 300               		.loc 1 528 0
 301 012e 9091 0000 		lds r25,UART_TxHead
 302 0132 9F5F      		subi r25,lo8(-(1))
 303 0134 9F77      		andi r25,lo8(127)
 304               	.LVL22:
 305               	.L14:
 529:src/uart.c    ****     
 530:src/uart.c    ****     while ( tmphead == UART_TxTail ){
 306               		.loc 1 530 0 discriminator 1
 307 0136 2091 0000 		lds r18,UART_TxTail
 308 013a 9217      		cp r25,r18
 309 013c 01F0      		breq .L14
 531:src/uart.c    ****         ;/* wait for free space in buffer */
 532:src/uart.c    ****     }
 533:src/uart.c    ****     
 534:src/uart.c    ****     UART_TxBuf[tmphead] = data;
 310               		.loc 1 534 0
 311 013e E92F      		mov r30,r25
 312 0140 F0E0      		ldi r31,0
 313 0142 E050      		subi r30,lo8(-(UART_TxBuf))
 314 0144 F040      		sbci r31,hi8(-(UART_TxBuf))
 315 0146 8083      		st Z,r24
 535:src/uart.c    ****     UART_TxHead = tmphead;
 316               		.loc 1 535 0
 317 0148 9093 0000 		sts UART_TxHead,r25
 536:src/uart.c    **** 
 537:src/uart.c    ****     /* enable UDRE interrupt */
 538:src/uart.c    ****     UART0_CONTROL    |= _BV(UART0_UDRIE);
 318               		.loc 1 538 0
 319 014c 8091 C100 		lds r24,193
 320               	.LVL23:
 321 0150 8062      		ori r24,lo8(32)
 322 0152 8093 C100 		sts 193,r24
 323 0156 0895      		ret
 324               		.cfi_endproc
 325               	.LFE5:
 327               	.global	uart_puts
 329               	uart_puts:
 330               	.LFB6:
 539:src/uart.c    **** 
 540:src/uart.c    **** }/* uart_putc */
 541:src/uart.c    **** 
 542:src/uart.c    **** 
 543:src/uart.c    **** /*************************************************************************
 544:src/uart.c    **** Function: uart_puts()
 545:src/uart.c    **** Purpose:  transmit string to UART
 546:src/uart.c    **** Input:    string to be transmitted
 547:src/uart.c    **** Returns:  none          
 548:src/uart.c    **** **************************************************************************/
 549:src/uart.c    **** void uart_puts(const char *s )
 550:src/uart.c    **** {
 331               		.loc 1 550 0
 332               		.cfi_startproc
 333               	.LVL24:
 334 0158 CF93      		push r28
 335               	.LCFI13:
 336               		.cfi_def_cfa_offset 3
 337               		.cfi_offset 28, -2
 338 015a DF93      		push r29
 339               	.LCFI14:
 340               		.cfi_def_cfa_offset 4
 341               		.cfi_offset 29, -3
 342               	/* prologue: function */
 343               	/* frame size = 0 */
 344               	/* stack size = 2 */
 345               	.L__stack_usage = 2
 346 015c EC01      		movw r28,r24
 347               	.LVL25:
 348               	.L17:
 551:src/uart.c    ****     while (*s) 
 349               		.loc 1 551 0
 350 015e 8991      		ld r24,Y+
 351               	.LVL26:
 352 0160 8823      		tst r24
 353 0162 01F0      		breq .L19
 354               	.LVL27:
 552:src/uart.c    ****       uart_putc(*s++);
 355               		.loc 1 552 0
 356 0164 0E94 0000 		call uart_putc
 357               	.LVL28:
 358 0168 00C0      		rjmp .L17
 359               	.LVL29:
 360               	.L19:
 361               	/* epilogue start */
 553:src/uart.c    **** 
 554:src/uart.c    **** }/* uart_puts */
 362               		.loc 1 554 0
 363 016a DF91      		pop r29
 364 016c CF91      		pop r28
 365               	.LVL30:
 366 016e 0895      		ret
 367               		.cfi_endproc
 368               	.LFE6:
 370               	.global	uart_puts_p
 372               	uart_puts_p:
 373               	.LFB7:
 555:src/uart.c    **** 
 556:src/uart.c    **** 
 557:src/uart.c    **** /*************************************************************************
 558:src/uart.c    **** Function: uart_puts_p()
 559:src/uart.c    **** Purpose:  transmit string from program memory to UART
 560:src/uart.c    **** Input:    program memory string to be transmitted
 561:src/uart.c    **** Returns:  none
 562:src/uart.c    **** **************************************************************************/
 563:src/uart.c    **** void uart_puts_p(const char *progmem_s )
 564:src/uart.c    **** {
 374               		.loc 1 564 0
 375               		.cfi_startproc
 376               	.LVL31:
 377 0170 CF93      		push r28
 378               	.LCFI15:
 379               		.cfi_def_cfa_offset 3
 380               		.cfi_offset 28, -2
 381 0172 DF93      		push r29
 382               	.LCFI16:
 383               		.cfi_def_cfa_offset 4
 384               		.cfi_offset 29, -3
 385               	/* prologue: function */
 386               	/* frame size = 0 */
 387               	/* stack size = 2 */
 388               	.L__stack_usage = 2
 389 0174 FC01      		movw r30,r24
 390               	.LVL32:
 391               	.L21:
 392               	.LBB2:
 565:src/uart.c    ****     register char c;
 566:src/uart.c    ****     
 567:src/uart.c    ****     while ( (c = pgm_read_byte(progmem_s++)) ) 
 393               		.loc 1 567 0
 394               	/* #APP */
 395               	 ;  567 "src/uart.c" 1
 396 0176 8491      		lpm r24, Z
 397               		
 398               	 ;  0 "" 2
 399               	.LVL33:
 400               	/* #NOAPP */
 401 0178 EF01      		movw r28,r30
 402 017a 2196      		adiw r28,1
 403               	.LVL34:
 404               	.LBE2:
 405 017c 8823      		tst r24
 406 017e 01F0      		breq .L23
 568:src/uart.c    ****       uart_putc(c);
 407               		.loc 1 568 0
 408 0180 0E94 0000 		call uart_putc
 409               	.LVL35:
 410 0184 FE01      		movw r30,r28
 411 0186 00C0      		rjmp .L21
 412               	.LVL36:
 413               	.L23:
 414               	/* epilogue start */
 569:src/uart.c    **** 
 570:src/uart.c    **** }/* uart_puts_p */
 415               		.loc 1 570 0
 416 0188 DF91      		pop r29
 417 018a CF91      		pop r28
 418               	.LVL37:
 419 018c 0895      		ret
 420               		.cfi_endproc
 421               	.LFE7:
 423               	.global	__vector_28
 425               	__vector_28:
 426               	.LFB8:
 571:src/uart.c    **** 
 572:src/uart.c    **** 
 573:src/uart.c    **** /*
 574:src/uart.c    ****  * these functions are only for ATmegas with two USART
 575:src/uart.c    ****  */
 576:src/uart.c    **** #if defined( ATMEGA_USART1 )
 577:src/uart.c    **** 
 578:src/uart.c    **** ISR(UART1_RECEIVE_INTERRUPT)
 579:src/uart.c    **** /*************************************************************************
 580:src/uart.c    **** Function: UART1 Receive Complete interrupt
 581:src/uart.c    **** Purpose:  called when the UART1 has received a character
 582:src/uart.c    **** **************************************************************************/
 583:src/uart.c    **** {
 427               		.loc 1 583 0
 428               		.cfi_startproc
 429 018e 1F92      		push r1
 430               	.LCFI17:
 431               		.cfi_def_cfa_offset 3
 432               		.cfi_offset 1, -2
 433 0190 0F92      		push r0
 434               	.LCFI18:
 435               		.cfi_def_cfa_offset 4
 436               		.cfi_offset 0, -3
 437 0192 0FB6      		in r0,__SREG__
 438 0194 0F92      		push r0
 439 0196 1124      		clr __zero_reg__
 440 0198 0BB6      		in r0,__RAMPZ__
 441 019a 0F92      		push r0
 442 019c 2F93      		push r18
 443               	.LCFI19:
 444               		.cfi_def_cfa_offset 5
 445               		.cfi_offset 18, -4
 446 019e 8F93      		push r24
 447               	.LCFI20:
 448               		.cfi_def_cfa_offset 6
 449               		.cfi_offset 24, -5
 450 01a0 9F93      		push r25
 451               	.LCFI21:
 452               		.cfi_def_cfa_offset 7
 453               		.cfi_offset 25, -6
 454 01a2 EF93      		push r30
 455               	.LCFI22:
 456               		.cfi_def_cfa_offset 8
 457               		.cfi_offset 30, -7
 458 01a4 FF93      		push r31
 459               	.LCFI23:
 460               		.cfi_def_cfa_offset 9
 461               		.cfi_offset 31, -8
 462               	/* prologue: Signal */
 463               	/* frame size = 0 */
 464               	/* stack size = 9 */
 465               	.L__stack_usage = 9
 584:src/uart.c    ****     unsigned char tmphead;
 585:src/uart.c    ****     unsigned char data;
 586:src/uart.c    ****     unsigned char usr;
 587:src/uart.c    ****     unsigned char lastRxError;
 588:src/uart.c    ****  
 589:src/uart.c    ****  
 590:src/uart.c    ****     /* read UART status register and UART data register */ 
 591:src/uart.c    ****     usr  = UART1_STATUS;
 466               		.loc 1 591 0
 467 01a6 8091 C800 		lds r24,200
 468               	.LVL38:
 592:src/uart.c    ****     data = UART1_DATA;
 469               		.loc 1 592 0
 470 01aa 9091 CE00 		lds r25,206
 471               	.LVL39:
 593:src/uart.c    ****     
 594:src/uart.c    ****     /* get FEn (Frame Error) DORn (Data OverRun) UPEn (USART Parity Error) bits */
 595:src/uart.c    ****     lastRxError = usr & (_BV(FE1)|_BV(DOR1)|_BV(UPE1) );
 472               		.loc 1 595 0
 473 01ae 8C71      		andi r24,lo8(28)
 474               	.LVL40:
 596:src/uart.c    ****             
 597:src/uart.c    ****     /* calculate buffer index */ 
 598:src/uart.c    ****     tmphead = ( UART1_RxHead + 1) & UART_RX_BUFFER_MASK;
 475               		.loc 1 598 0
 476 01b0 E091 0000 		lds r30,UART1_RxHead
 477 01b4 EF5F      		subi r30,lo8(-(1))
 478 01b6 EF77      		andi r30,lo8(127)
 479               	.LVL41:
 599:src/uart.c    ****     
 600:src/uart.c    ****     if ( tmphead == UART1_RxTail ) {
 480               		.loc 1 600 0
 481 01b8 2091 0000 		lds r18,UART1_RxTail
 482 01bc E217      		cp r30,r18
 483 01be 01F0      		breq .L26
 601:src/uart.c    ****         /* error: receive buffer overflow */
 602:src/uart.c    ****         lastRxError = UART_BUFFER_OVERFLOW >> 8;
 603:src/uart.c    ****     }else{
 604:src/uart.c    ****         /* store new index */
 605:src/uart.c    ****         UART1_RxHead = tmphead;
 484               		.loc 1 605 0
 485 01c0 E093 0000 		sts UART1_RxHead,r30
 606:src/uart.c    ****         /* store received data in buffer */
 607:src/uart.c    ****         UART1_RxBuf[tmphead] = data;
 486               		.loc 1 607 0
 487 01c4 F0E0      		ldi r31,0
 488 01c6 E050      		subi r30,lo8(-(UART1_RxBuf))
 489 01c8 F040      		sbci r31,hi8(-(UART1_RxBuf))
 490               	.LVL42:
 491 01ca 9083      		st Z,r25
 492               	.LVL43:
 493 01cc 00C0      		rjmp .L25
 494               	.LVL44:
 495               	.L26:
 602:src/uart.c    ****     }else{
 496               		.loc 1 602 0
 497 01ce 82E0      		ldi r24,lo8(2)
 498               	.LVL45:
 499               	.L25:
 608:src/uart.c    ****     }
 609:src/uart.c    ****     UART1_LastRxError |= lastRxError;   
 500               		.loc 1 609 0
 501 01d0 9091 0000 		lds r25,UART1_LastRxError
 502               	.LVL46:
 503 01d4 892B      		or r24,r25
 504               	.LVL47:
 505 01d6 8093 0000 		sts UART1_LastRxError,r24
 506               	/* epilogue start */
 610:src/uart.c    **** }
 507               		.loc 1 610 0
 508 01da FF91      		pop r31
 509 01dc EF91      		pop r30
 510 01de 9F91      		pop r25
 511 01e0 8F91      		pop r24
 512 01e2 2F91      		pop r18
 513 01e4 0F90      		pop r0
 514 01e6 0BBE      		out __RAMPZ__,r0
 515 01e8 0F90      		pop r0
 516 01ea 0FBE      		out __SREG__,r0
 517 01ec 0F90      		pop r0
 518 01ee 1F90      		pop r1
 519 01f0 1895      		reti
 520               		.cfi_endproc
 521               	.LFE8:
 523               	.global	__vector_29
 525               	__vector_29:
 526               	.LFB9:
 611:src/uart.c    **** 
 612:src/uart.c    **** 
 613:src/uart.c    **** ISR(UART1_TRANSMIT_INTERRUPT)
 614:src/uart.c    **** /*************************************************************************
 615:src/uart.c    **** Function: UART1 Data Register Empty interrupt
 616:src/uart.c    **** Purpose:  called when the UART1 is ready to transmit the next byte
 617:src/uart.c    **** **************************************************************************/
 618:src/uart.c    **** {
 527               		.loc 1 618 0
 528               		.cfi_startproc
 529 01f2 1F92      		push r1
 530               	.LCFI24:
 531               		.cfi_def_cfa_offset 3
 532               		.cfi_offset 1, -2
 533 01f4 0F92      		push r0
 534               	.LCFI25:
 535               		.cfi_def_cfa_offset 4
 536               		.cfi_offset 0, -3
 537 01f6 0FB6      		in r0,__SREG__
 538 01f8 0F92      		push r0
 539 01fa 1124      		clr __zero_reg__
 540 01fc 0BB6      		in r0,__RAMPZ__
 541 01fe 0F92      		push r0
 542 0200 8F93      		push r24
 543               	.LCFI26:
 544               		.cfi_def_cfa_offset 5
 545               		.cfi_offset 24, -4
 546 0202 9F93      		push r25
 547               	.LCFI27:
 548               		.cfi_def_cfa_offset 6
 549               		.cfi_offset 25, -5
 550 0204 EF93      		push r30
 551               	.LCFI28:
 552               		.cfi_def_cfa_offset 7
 553               		.cfi_offset 30, -6
 554 0206 FF93      		push r31
 555               	.LCFI29:
 556               		.cfi_def_cfa_offset 8
 557               		.cfi_offset 31, -7
 558               	/* prologue: Signal */
 559               	/* frame size = 0 */
 560               	/* stack size = 8 */
 561               	.L__stack_usage = 8
 619:src/uart.c    ****     unsigned char tmptail;
 620:src/uart.c    **** 
 621:src/uart.c    ****     
 622:src/uart.c    ****     if ( UART1_TxHead != UART1_TxTail) {
 562               		.loc 1 622 0
 563 0208 9091 0000 		lds r25,UART1_TxHead
 564 020c 8091 0000 		lds r24,UART1_TxTail
 565 0210 9817      		cp r25,r24
 566 0212 01F0      		breq .L28
 623:src/uart.c    ****         /* calculate and store new buffer index */
 624:src/uart.c    ****         tmptail = (UART1_TxTail + 1) & UART_TX_BUFFER_MASK;
 567               		.loc 1 624 0
 568 0214 E091 0000 		lds r30,UART1_TxTail
 569 0218 EF5F      		subi r30,lo8(-(1))
 570 021a EF77      		andi r30,lo8(127)
 571               	.LVL48:
 625:src/uart.c    ****         UART1_TxTail = tmptail;
 572               		.loc 1 625 0
 573 021c E093 0000 		sts UART1_TxTail,r30
 626:src/uart.c    ****         /* get one byte from buffer and write it to UART */
 627:src/uart.c    ****         UART1_DATA = UART1_TxBuf[tmptail];  /* start transmission */
 574               		.loc 1 627 0
 575 0220 F0E0      		ldi r31,0
 576 0222 E050      		subi r30,lo8(-(UART1_TxBuf))
 577 0224 F040      		sbci r31,hi8(-(UART1_TxBuf))
 578               	.LVL49:
 579 0226 8081      		ld r24,Z
 580 0228 8093 CE00 		sts 206,r24
 581               	.LVL50:
 582 022c 00C0      		rjmp .L27
 583               	.L28:
 628:src/uart.c    ****     }else{
 629:src/uart.c    ****         /* tx buffer empty, disable UDRE interrupt */
 630:src/uart.c    ****         UART1_CONTROL &= ~_BV(UART1_UDRIE);
 584               		.loc 1 630 0
 585 022e 8091 C900 		lds r24,201
 586 0232 8F7D      		andi r24,lo8(-33)
 587 0234 8093 C900 		sts 201,r24
 588               	.L27:
 589               	/* epilogue start */
 631:src/uart.c    ****     }
 632:src/uart.c    **** }
 590               		.loc 1 632 0
 591 0238 FF91      		pop r31
 592 023a EF91      		pop r30
 593 023c 9F91      		pop r25
 594 023e 8F91      		pop r24
 595 0240 0F90      		pop r0
 596 0242 0BBE      		out __RAMPZ__,r0
 597 0244 0F90      		pop r0
 598 0246 0FBE      		out __SREG__,r0
 599 0248 0F90      		pop r0
 600 024a 1F90      		pop r1
 601 024c 1895      		reti
 602               		.cfi_endproc
 603               	.LFE9:
 605               	.global	uart1_init
 607               	uart1_init:
 608               	.LFB10:
 633:src/uart.c    **** 
 634:src/uart.c    **** 
 635:src/uart.c    **** /*************************************************************************
 636:src/uart.c    **** Function: uart1_init()
 637:src/uart.c    **** Purpose:  initialize UART1 and set baudrate
 638:src/uart.c    **** Input:    baudrate using macro UART_BAUD_SELECT()
 639:src/uart.c    **** Returns:  none
 640:src/uart.c    **** **************************************************************************/
 641:src/uart.c    **** void uart1_init(unsigned int baudrate)
 642:src/uart.c    **** {
 609               		.loc 1 642 0
 610               		.cfi_startproc
 611               	.LVL51:
 612               	/* prologue: function */
 613               	/* frame size = 0 */
 614               	/* stack size = 0 */
 615               	.L__stack_usage = 0
 643:src/uart.c    ****     UART1_TxHead = 0;
 616               		.loc 1 643 0
 617 024e 1092 0000 		sts UART1_TxHead,__zero_reg__
 644:src/uart.c    ****     UART1_TxTail = 0;
 618               		.loc 1 644 0
 619 0252 1092 0000 		sts UART1_TxTail,__zero_reg__
 645:src/uart.c    ****     UART1_RxHead = 0;
 620               		.loc 1 645 0
 621 0256 1092 0000 		sts UART1_RxHead,__zero_reg__
 646:src/uart.c    ****     UART1_RxTail = 0;
 622               		.loc 1 646 0
 623 025a 1092 0000 		sts UART1_RxTail,__zero_reg__
 647:src/uart.c    **** 
 648:src/uart.c    **** #ifdef UART_TEST
 649:src/uart.c    **** #ifndef UART1_BIT_U2X
 650:src/uart.c    **** #warning "UART1_BIT_U2X not defined"
 651:src/uart.c    **** #endif
 652:src/uart.c    **** #ifndef UART1_UBRRH
 653:src/uart.c    **** #warning "UART1_UBRRH not defined"
 654:src/uart.c    **** #endif
 655:src/uart.c    **** #ifndef UART1_CONTROLC
 656:src/uart.c    **** #warning "UART1_CONTROLC not defined"
 657:src/uart.c    **** #endif
 658:src/uart.c    **** #if defined(URSEL) || defined(URSEL1)
 659:src/uart.c    **** #ifndef UART1_BIT_URSEL
 660:src/uart.c    **** #warning "UART1_BIT_URSEL not defined"
 661:src/uart.c    **** #endif
 662:src/uart.c    **** #endif
 663:src/uart.c    **** #endif
 664:src/uart.c    **** 
 665:src/uart.c    ****     /* Set baud rate */
 666:src/uart.c    ****     if ( baudrate & 0x8000 ) 
 624               		.loc 1 666 0
 625 025e 97FF      		sbrs r25,7
 626 0260 00C0      		rjmp .L31
 667:src/uart.c    ****     {
 668:src/uart.c    ****         #if UART1_BIT_U2X
 669:src/uart.c    ****     	UART1_STATUS = (1<<UART1_BIT_U2X);  //Enable 2x speed 
 627               		.loc 1 669 0
 628 0262 22E0      		ldi r18,lo8(2)
 629 0264 2093 C800 		sts 200,r18
 630               	.L31:
 670:src/uart.c    ****         #endif
 671:src/uart.c    ****     }
 672:src/uart.c    ****     UART1_UBRRH = (unsigned char)((baudrate>>8)&0x80) ;
 631               		.loc 1 672 0
 632 0268 9078      		andi r25,lo8(-128)
 633 026a 9093 CD00 		sts 205,r25
 673:src/uart.c    ****     UART1_UBRRL = (unsigned char) baudrate;
 634               		.loc 1 673 0
 635 026e 8093 CC00 		sts 204,r24
 674:src/uart.c    ****         
 675:src/uart.c    ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 676:src/uart.c    ****     UART1_CONTROL = _BV(UART1_BIT_RXCIE)|(1<<UART1_BIT_RXEN)|(1<<UART1_BIT_TXEN);    
 636               		.loc 1 676 0
 637 0272 88E9      		ldi r24,lo8(-104)
 638               	.LVL52:
 639 0274 8093 C900 		sts 201,r24
 677:src/uart.c    ****     
 678:src/uart.c    ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */   
 679:src/uart.c    ****     #ifdef UART1_BIT_URSEL
 680:src/uart.c    ****     UART1_CONTROLC = (1<<UART1_BIT_URSEL)|(1<<UART1_BIT_UCSZ1)|(1<<UART1_BIT_UCSZ0);
 681:src/uart.c    ****     #else
 682:src/uart.c    ****     UART1_CONTROLC = (1<<UART1_BIT_UCSZ1)|(1<<UART1_BIT_UCSZ0);
 640               		.loc 1 682 0
 641 0278 86E0      		ldi r24,lo8(6)
 642 027a 8093 CA00 		sts 202,r24
 643 027e 0895      		ret
 644               		.cfi_endproc
 645               	.LFE10:
 647               	.global	uart1_getc
 649               	uart1_getc:
 650               	.LFB11:
 683:src/uart.c    ****     #endif 
 684:src/uart.c    ****     
 685:src/uart.c    **** }/* uart_init */
 686:src/uart.c    **** 
 687:src/uart.c    **** 
 688:src/uart.c    **** /*************************************************************************
 689:src/uart.c    **** Function: uart1_getc()
 690:src/uart.c    **** Purpose:  return byte from ringbuffer  
 691:src/uart.c    **** Returns:  lower byte:  received byte from ringbuffer
 692:src/uart.c    ****           higher byte: last receive error
 693:src/uart.c    **** **************************************************************************/
 694:src/uart.c    **** unsigned int uart1_getc(void)
 695:src/uart.c    **** {    
 651               		.loc 1 695 0
 652               		.cfi_startproc
 653               	/* prologue: function */
 654               	/* frame size = 0 */
 655               	/* stack size = 0 */
 656               	.L__stack_usage = 0
 696:src/uart.c    ****     unsigned char tmptail;
 697:src/uart.c    ****     unsigned int  data;
 698:src/uart.c    ****     unsigned char lastRxError;
 699:src/uart.c    **** 
 700:src/uart.c    **** 
 701:src/uart.c    ****     if ( UART1_RxHead == UART1_RxTail ) {
 657               		.loc 1 701 0
 658 0280 9091 0000 		lds r25,UART1_RxHead
 659 0284 8091 0000 		lds r24,UART1_RxTail
 660 0288 9817      		cp r25,r24
 661 028a 01F0      		breq .L34
 702:src/uart.c    ****         return UART_NO_DATA;   /* no data available */
 703:src/uart.c    ****     }
 704:src/uart.c    ****     
 705:src/uart.c    ****     /* calculate buffer index */
 706:src/uart.c    ****     tmptail = (UART1_RxTail + 1) & UART_RX_BUFFER_MASK;
 662               		.loc 1 706 0
 663 028c 9091 0000 		lds r25,UART1_RxTail
 664 0290 9F5F      		subi r25,lo8(-(1))
 665 0292 9F77      		andi r25,lo8(127)
 666               	.LVL53:
 707:src/uart.c    ****     
 708:src/uart.c    ****     /* get data from receive buffer */
 709:src/uart.c    ****     data = UART1_RxBuf[tmptail];
 667               		.loc 1 709 0
 668 0294 E92F      		mov r30,r25
 669 0296 F0E0      		ldi r31,0
 670 0298 E050      		subi r30,lo8(-(UART1_RxBuf))
 671 029a F040      		sbci r31,hi8(-(UART1_RxBuf))
 672 029c 2081      		ld r18,Z
 673               	.LVL54:
 710:src/uart.c    ****     lastRxError = UART1_LastRxError;
 674               		.loc 1 710 0
 675 029e 8091 0000 		lds r24,UART1_LastRxError
 676               	.LVL55:
 711:src/uart.c    ****     
 712:src/uart.c    ****     /* store buffer index */
 713:src/uart.c    ****     UART1_RxTail = tmptail; 
 677               		.loc 1 713 0
 678 02a2 9093 0000 		sts UART1_RxTail,r25
 714:src/uart.c    ****     
 715:src/uart.c    ****     UART1_LastRxError = 0;
 679               		.loc 1 715 0
 680 02a6 1092 0000 		sts UART1_LastRxError,__zero_reg__
 716:src/uart.c    ****     return (lastRxError << 8) + data;
 681               		.loc 1 716 0
 682 02aa 90E0      		ldi r25,0
 683               	.LVL56:
 684 02ac 982F      		mov r25,r24
 685 02ae 8827      		clr r24
 686               	.LVL57:
 687 02b0 820F      		add r24,r18
 688 02b2 911D      		adc r25,__zero_reg__
 689 02b4 0895      		ret
 690               	.LVL58:
 691               	.L34:
 702:src/uart.c    ****     }
 692               		.loc 1 702 0
 693 02b6 80E0      		ldi r24,0
 694 02b8 91E0      		ldi r25,lo8(1)
 717:src/uart.c    **** 
 718:src/uart.c    **** }/* uart1_getc */
 695               		.loc 1 718 0
 696 02ba 0895      		ret
 697               		.cfi_endproc
 698               	.LFE11:
 700               	.global	uart1_putc
 702               	uart1_putc:
 703               	.LFB12:
 719:src/uart.c    **** 
 720:src/uart.c    **** 
 721:src/uart.c    **** /*************************************************************************
 722:src/uart.c    **** Function: uart1_putc()
 723:src/uart.c    **** Purpose:  write byte to ringbuffer for transmitting via UART
 724:src/uart.c    **** Input:    byte to be transmitted
 725:src/uart.c    **** Returns:  none          
 726:src/uart.c    **** **************************************************************************/
 727:src/uart.c    **** void uart1_putc(unsigned char data)
 728:src/uart.c    **** {
 704               		.loc 1 728 0
 705               		.cfi_startproc
 706               	.LVL59:
 707               	/* prologue: function */
 708               	/* frame size = 0 */
 709               	/* stack size = 0 */
 710               	.L__stack_usage = 0
 729:src/uart.c    ****     unsigned char tmphead;
 730:src/uart.c    **** 
 731:src/uart.c    ****     
 732:src/uart.c    ****     tmphead  = (UART1_TxHead + 1) & UART_TX_BUFFER_MASK;
 711               		.loc 1 732 0
 712 02bc 9091 0000 		lds r25,UART1_TxHead
 713 02c0 9F5F      		subi r25,lo8(-(1))
 714 02c2 9F77      		andi r25,lo8(127)
 715               	.LVL60:
 716               	.L36:
 733:src/uart.c    ****     
 734:src/uart.c    ****     while ( tmphead == UART1_TxTail ){
 717               		.loc 1 734 0 discriminator 1
 718 02c4 2091 0000 		lds r18,UART1_TxTail
 719 02c8 9217      		cp r25,r18
 720 02ca 01F0      		breq .L36
 735:src/uart.c    ****         ;/* wait for free space in buffer */
 736:src/uart.c    ****     }
 737:src/uart.c    ****     
 738:src/uart.c    ****     UART1_TxBuf[tmphead] = data;
 721               		.loc 1 738 0
 722 02cc E92F      		mov r30,r25
 723 02ce F0E0      		ldi r31,0
 724 02d0 E050      		subi r30,lo8(-(UART1_TxBuf))
 725 02d2 F040      		sbci r31,hi8(-(UART1_TxBuf))
 726 02d4 8083      		st Z,r24
 739:src/uart.c    ****     UART1_TxHead = tmphead;
 727               		.loc 1 739 0
 728 02d6 9093 0000 		sts UART1_TxHead,r25
 740:src/uart.c    **** 
 741:src/uart.c    ****     /* enable UDRE interrupt */
 742:src/uart.c    ****     UART1_CONTROL    |= _BV(UART1_UDRIE);
 729               		.loc 1 742 0
 730 02da 8091 C900 		lds r24,201
 731               	.LVL61:
 732 02de 8062      		ori r24,lo8(32)
 733 02e0 8093 C900 		sts 201,r24
 734 02e4 0895      		ret
 735               		.cfi_endproc
 736               	.LFE12:
 738               	.global	uart1_puts
 740               	uart1_puts:
 741               	.LFB13:
 743:src/uart.c    **** 
 744:src/uart.c    **** }/* uart1_putc */
 745:src/uart.c    **** 
 746:src/uart.c    **** 
 747:src/uart.c    **** /*************************************************************************
 748:src/uart.c    **** Function: uart1_puts()
 749:src/uart.c    **** Purpose:  transmit string to UART1
 750:src/uart.c    **** Input:    string to be transmitted
 751:src/uart.c    **** Returns:  none          
 752:src/uart.c    **** **************************************************************************/
 753:src/uart.c    **** void uart1_puts(const char *s )
 754:src/uart.c    **** {
 742               		.loc 1 754 0
 743               		.cfi_startproc
 744               	.LVL62:
 745 02e6 CF93      		push r28
 746               	.LCFI30:
 747               		.cfi_def_cfa_offset 3
 748               		.cfi_offset 28, -2
 749 02e8 DF93      		push r29
 750               	.LCFI31:
 751               		.cfi_def_cfa_offset 4
 752               		.cfi_offset 29, -3
 753               	/* prologue: function */
 754               	/* frame size = 0 */
 755               	/* stack size = 2 */
 756               	.L__stack_usage = 2
 757 02ea EC01      		movw r28,r24
 758               	.LVL63:
 759               	.L39:
 755:src/uart.c    ****     while (*s) 
 760               		.loc 1 755 0
 761 02ec 8991      		ld r24,Y+
 762               	.LVL64:
 763 02ee 8823      		tst r24
 764 02f0 01F0      		breq .L41
 765               	.LVL65:
 756:src/uart.c    ****       uart1_putc(*s++);
 766               		.loc 1 756 0
 767 02f2 0E94 0000 		call uart1_putc
 768               	.LVL66:
 769 02f6 00C0      		rjmp .L39
 770               	.LVL67:
 771               	.L41:
 772               	/* epilogue start */
 757:src/uart.c    **** 
 758:src/uart.c    **** }/* uart1_puts */
 773               		.loc 1 758 0
 774 02f8 DF91      		pop r29
 775 02fa CF91      		pop r28
 776               	.LVL68:
 777 02fc 0895      		ret
 778               		.cfi_endproc
 779               	.LFE13:
 781               	.global	uart1_puts_p
 783               	uart1_puts_p:
 784               	.LFB14:
 759:src/uart.c    **** 
 760:src/uart.c    **** 
 761:src/uart.c    **** /*************************************************************************
 762:src/uart.c    **** Function: uart1_puts_p()
 763:src/uart.c    **** Purpose:  transmit string from program memory to UART1
 764:src/uart.c    **** Input:    program memory string to be transmitted
 765:src/uart.c    **** Returns:  none
 766:src/uart.c    **** **************************************************************************/
 767:src/uart.c    **** void uart1_puts_p(const char *progmem_s )
 768:src/uart.c    **** {
 785               		.loc 1 768 0
 786               		.cfi_startproc
 787               	.LVL69:
 788 02fe CF93      		push r28
 789               	.LCFI32:
 790               		.cfi_def_cfa_offset 3
 791               		.cfi_offset 28, -2
 792 0300 DF93      		push r29
 793               	.LCFI33:
 794               		.cfi_def_cfa_offset 4
 795               		.cfi_offset 29, -3
 796               	/* prologue: function */
 797               	/* frame size = 0 */
 798               	/* stack size = 2 */
 799               	.L__stack_usage = 2
 800 0302 FC01      		movw r30,r24
 801               	.LVL70:
 802               	.L43:
 803               	.LBB3:
 769:src/uart.c    ****     register char c;
 770:src/uart.c    ****     
 771:src/uart.c    ****     while ( (c = pgm_read_byte(progmem_s++)) ) 
 804               		.loc 1 771 0
 805               	/* #APP */
 806               	 ;  771 "src/uart.c" 1
 807 0304 8491      		lpm r24, Z
 808               		
 809               	 ;  0 "" 2
 810               	.LVL71:
 811               	/* #NOAPP */
 812 0306 EF01      		movw r28,r30
 813 0308 2196      		adiw r28,1
 814               	.LVL72:
 815               	.LBE3:
 816 030a 8823      		tst r24
 817 030c 01F0      		breq .L45
 772:src/uart.c    ****       uart1_putc(c);
 818               		.loc 1 772 0
 819 030e 0E94 0000 		call uart1_putc
 820               	.LVL73:
 821 0312 FE01      		movw r30,r28
 822 0314 00C0      		rjmp .L43
 823               	.LVL74:
 824               	.L45:
 825               	/* epilogue start */
 773:src/uart.c    **** 
 774:src/uart.c    **** }/* uart1_puts_p */
 826               		.loc 1 774 0
 827 0316 DF91      		pop r29
 828 0318 CF91      		pop r28
 829               	.LVL75:
 830 031a 0895      		ret
 831               		.cfi_endproc
 832               	.LFE14:
 834               		.local	UART1_LastRxError
 835               		.comm	UART1_LastRxError,1,1
 836               		.local	UART1_RxTail
 837               		.comm	UART1_RxTail,1,1
 838               		.local	UART1_RxHead
 839               		.comm	UART1_RxHead,1,1
 840               		.local	UART1_TxTail
 841               		.comm	UART1_TxTail,1,1
 842               		.local	UART1_TxHead
 843               		.comm	UART1_TxHead,1,1
 844               		.local	UART1_RxBuf
 845               		.comm	UART1_RxBuf,128,1
 846               		.local	UART1_TxBuf
 847               		.comm	UART1_TxBuf,128,1
 848               		.local	UART_LastRxError
 849               		.comm	UART_LastRxError,1,1
 850               		.local	UART_RxTail
 851               		.comm	UART_RxTail,1,1
 852               		.local	UART_RxHead
 853               		.comm	UART_RxHead,1,1
 854               		.local	UART_TxTail
 855               		.comm	UART_TxTail,1,1
 856               		.local	UART_TxHead
 857               		.comm	UART_TxHead,1,1
 858               		.local	UART_RxBuf
 859               		.comm	UART_RxBuf,128,1
 860               		.local	UART_TxBuf
 861               		.comm	UART_TxBuf,128,1
 862               	.Letext0:
 863               		.file 2 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 uart.c
     /tmp/ccoC6n22.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccoC6n22.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccoC6n22.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccoC6n22.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccoC6n22.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccoC6n22.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccoC6n22.s:13     .text:0000000000000000 __vector_20
     /tmp/ccoC6n22.s:851    .bss:0000000000000107 UART_RxHead
     /tmp/ccoC6n22.s:849    .bss:0000000000000106 UART_RxTail
     /tmp/ccoC6n22.s:857    .bss:000000000000010a UART_RxBuf
     /tmp/ccoC6n22.s:847    .bss:0000000000000105 UART_LastRxError
     /tmp/ccoC6n22.s:114    .text:0000000000000064 __vector_21
     /tmp/ccoC6n22.s:855    .bss:0000000000000109 UART_TxHead
     /tmp/ccoC6n22.s:853    .bss:0000000000000108 UART_TxTail
     /tmp/ccoC6n22.s:859    .bss:000000000000018a UART_TxBuf
     /tmp/ccoC6n22.s:196    .text:00000000000000c0 uart_init
     /tmp/ccoC6n22.s:238    .text:00000000000000f2 uart_getc
     /tmp/ccoC6n22.s:291    .text:000000000000012e uart_putc
     /tmp/ccoC6n22.s:329    .text:0000000000000158 uart_puts
     /tmp/ccoC6n22.s:372    .text:0000000000000170 uart_puts_p
     /tmp/ccoC6n22.s:425    .text:000000000000018e __vector_28
     /tmp/ccoC6n22.s:837    .bss:0000000000000002 UART1_RxHead
     /tmp/ccoC6n22.s:835    .bss:0000000000000001 UART1_RxTail
     /tmp/ccoC6n22.s:843    .bss:0000000000000005 UART1_RxBuf
                             .bss:0000000000000000 UART1_LastRxError
     /tmp/ccoC6n22.s:525    .text:00000000000001f2 __vector_29
     /tmp/ccoC6n22.s:841    .bss:0000000000000004 UART1_TxHead
     /tmp/ccoC6n22.s:839    .bss:0000000000000003 UART1_TxTail
     /tmp/ccoC6n22.s:845    .bss:0000000000000085 UART1_TxBuf
     /tmp/ccoC6n22.s:607    .text:000000000000024e uart1_init
     /tmp/ccoC6n22.s:649    .text:0000000000000280 uart1_getc
     /tmp/ccoC6n22.s:702    .text:00000000000002bc uart1_putc
     /tmp/ccoC6n22.s:740    .text:00000000000002e6 uart1_puts
     /tmp/ccoC6n22.s:783    .text:00000000000002fe uart1_puts_p

UNDEFINED SYMBOLS
__do_clear_bss
